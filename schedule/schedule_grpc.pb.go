// Copyright © 2023 OpenIM. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v5.27.3
// source: schedule/schedule.proto

package schedule

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Schedule_CreateSchedule_FullMethodName         = "/openim.schedule.Schedule/CreateSchedule"
	Schedule_UpdateSchedule_FullMethodName         = "/openim.schedule.Schedule/UpdateSchedule"
	Schedule_DeleteSchedule_FullMethodName         = "/openim.schedule.Schedule/DeleteSchedule"
	Schedule_GetSchedule_FullMethodName            = "/openim.schedule.Schedule/GetSchedule"
	Schedule_GetSchedules_FullMethodName           = "/openim.schedule.Schedule/GetSchedules"
	Schedule_AcceptSchedule_FullMethodName         = "/openim.schedule.Schedule/AcceptSchedule"
	Schedule_RejectSchedule_FullMethodName         = "/openim.schedule.Schedule/RejectSchedule"
	Schedule_JoinSchedule_FullMethodName           = "/openim.schedule.Schedule/JoinSchedule"
	Schedule_SetReminder_FullMethodName            = "/openim.schedule.Schedule/SetReminder"
	Schedule_CheckConflict_FullMethodName          = "/openim.schedule.Schedule/CheckConflict"
	Schedule_GetScheduleDates_FullMethodName       = "/openim.schedule.Schedule/GetScheduleDates"
	Schedule_GetScheduleMonthView_FullMethodName   = "/openim.schedule.Schedule/GetScheduleMonthView"
	Schedule_CreateScheduleMessage_FullMethodName  = "/openim.schedule.Schedule/CreateScheduleMessage"
	Schedule_InitScheduleGroups_FullMethodName     = "/openim.schedule.Schedule/InitScheduleGroups"
	Schedule_GetAllScheduleGroups_FullMethodName   = "/openim.schedule.Schedule/GetAllScheduleGroups"
	Schedule_CreateScheduleGroup_FullMethodName    = "/openim.schedule.Schedule/CreateScheduleGroup"
	Schedule_UpdateScheduleGroup_FullMethodName    = "/openim.schedule.Schedule/UpdateScheduleGroup"
	Schedule_DeleteScheduleGroup_FullMethodName    = "/openim.schedule.Schedule/DeleteScheduleGroup"
	Schedule_QuitScheduleGroup_FullMethodName      = "/openim.schedule.Schedule/QuitScheduleGroup"
	Schedule_GetScheduleGroupDetail_FullMethodName = "/openim.schedule.Schedule/GetScheduleGroupDetail"
)

// ScheduleClient is the client API for Schedule service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Schedule 日程服务
type ScheduleClient interface {
	// 创建日程
	CreateSchedule(ctx context.Context, in *CreateScheduleReq, opts ...grpc.CallOption) (*CreateScheduleResp, error)
	// 更新日程
	UpdateSchedule(ctx context.Context, in *UpdateScheduleReq, opts ...grpc.CallOption) (*UpdateScheduleResp, error)
	// 删除日程
	DeleteSchedule(ctx context.Context, in *DeleteScheduleReq, opts ...grpc.CallOption) (*DeleteScheduleResp, error)
	// 查询日程详情
	GetSchedule(ctx context.Context, in *GetScheduleReq, opts ...grpc.CallOption) (*GetScheduleResp, error)
	// 查询日程列表
	GetSchedules(ctx context.Context, in *GetSchedulesReq, opts ...grpc.CallOption) (*GetSchedulesResp, error)
	// 接受日程邀请（支持状态切换：无论当前状态是待确认、已接受还是已拒绝，都可以调用此接口接受日程）
	AcceptSchedule(ctx context.Context, in *AcceptScheduleReq, opts ...grpc.CallOption) (*AcceptScheduleResp, error)
	// 拒绝日程邀请（支持状态切换：无论当前状态是待确认、已接受还是已拒绝，都可以调用此接口拒绝日程）
	RejectSchedule(ctx context.Context, in *RejectScheduleReq, opts ...grpc.CallOption) (*RejectScheduleResp, error)
	// 加入日程（主动加入，不是接受邀请。加入后会自动发送日程会话消息给创建者）
	JoinSchedule(ctx context.Context, in *JoinScheduleReq, opts ...grpc.CallOption) (*JoinScheduleResp, error)
	// 设置提醒
	SetReminder(ctx context.Context, in *SetReminderReq, opts ...grpc.CallOption) (*SetReminderResp, error)
	// 查询日程冲突
	CheckConflict(ctx context.Context, in *CheckConflictReq, opts ...grpc.CallOption) (*CheckConflictResp, error)
	// 查询某个月有参与日程的日期列表（用于日历标记）
	GetScheduleDates(ctx context.Context, in *GetScheduleDatesReq, opts ...grpc.CallOption) (*GetScheduleDatesResp, error)
	// 查询某个月每天的所有日程（月历视图）
	GetScheduleMonthView(ctx context.Context, in *GetScheduleMonthViewReq, opts ...grpc.CallOption) (*GetScheduleMonthViewResp, error)
	// 发送日程消息到聊天（2个人是单聊，3个及以上是群聊）
	CreateScheduleMessage(ctx context.Context, in *CreateScheduleMessageReq, opts ...grpc.CallOption) (*CreateScheduleMessageResp, error)
	// 初始化日程分组（创建默认分组）
	InitScheduleGroups(ctx context.Context, in *InitScheduleGroupsReq, opts ...grpc.CallOption) (*InitScheduleGroupsResp, error)
	// 获取所有日程分组
	GetAllScheduleGroups(ctx context.Context, in *GetAllScheduleGroupsReq, opts ...grpc.CallOption) (*GetAllScheduleGroupsResp, error)
	// 创建自定义日程分组
	CreateScheduleGroup(ctx context.Context, in *CreateScheduleGroupReq, opts ...grpc.CallOption) (*CreateScheduleGroupResp, error)
	// 更新日程分组信息
	UpdateScheduleGroup(ctx context.Context, in *UpdateScheduleGroupReq, opts ...grpc.CallOption) (*UpdateScheduleGroupResp, error)
	// 删除日程分组
	DeleteScheduleGroup(ctx context.Context, in *DeleteScheduleGroupReq, opts ...grpc.CallOption) (*DeleteScheduleGroupResp, error)
	// 退出日程分组（被共享的用户主动退出他人共享的分组）
	QuitScheduleGroup(ctx context.Context, in *QuitScheduleGroupReq, opts ...grpc.CallOption) (*QuitScheduleGroupResp, error)
	// 获取日程分组详情
	GetScheduleGroupDetail(ctx context.Context, in *GetScheduleGroupDetailReq, opts ...grpc.CallOption) (*GetScheduleGroupDetailResp, error)
}

type scheduleClient struct {
	cc grpc.ClientConnInterface
}

func NewScheduleClient(cc grpc.ClientConnInterface) ScheduleClient {
	return &scheduleClient{cc}
}

func (c *scheduleClient) CreateSchedule(ctx context.Context, in *CreateScheduleReq, opts ...grpc.CallOption) (*CreateScheduleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateScheduleResp)
	err := c.cc.Invoke(ctx, Schedule_CreateSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) UpdateSchedule(ctx context.Context, in *UpdateScheduleReq, opts ...grpc.CallOption) (*UpdateScheduleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScheduleResp)
	err := c.cc.Invoke(ctx, Schedule_UpdateSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) DeleteSchedule(ctx context.Context, in *DeleteScheduleReq, opts ...grpc.CallOption) (*DeleteScheduleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteScheduleResp)
	err := c.cc.Invoke(ctx, Schedule_DeleteSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) GetSchedule(ctx context.Context, in *GetScheduleReq, opts ...grpc.CallOption) (*GetScheduleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetScheduleResp)
	err := c.cc.Invoke(ctx, Schedule_GetSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) GetSchedules(ctx context.Context, in *GetSchedulesReq, opts ...grpc.CallOption) (*GetSchedulesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSchedulesResp)
	err := c.cc.Invoke(ctx, Schedule_GetSchedules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) AcceptSchedule(ctx context.Context, in *AcceptScheduleReq, opts ...grpc.CallOption) (*AcceptScheduleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcceptScheduleResp)
	err := c.cc.Invoke(ctx, Schedule_AcceptSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) RejectSchedule(ctx context.Context, in *RejectScheduleReq, opts ...grpc.CallOption) (*RejectScheduleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RejectScheduleResp)
	err := c.cc.Invoke(ctx, Schedule_RejectSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) JoinSchedule(ctx context.Context, in *JoinScheduleReq, opts ...grpc.CallOption) (*JoinScheduleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinScheduleResp)
	err := c.cc.Invoke(ctx, Schedule_JoinSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) SetReminder(ctx context.Context, in *SetReminderReq, opts ...grpc.CallOption) (*SetReminderResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetReminderResp)
	err := c.cc.Invoke(ctx, Schedule_SetReminder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) CheckConflict(ctx context.Context, in *CheckConflictReq, opts ...grpc.CallOption) (*CheckConflictResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckConflictResp)
	err := c.cc.Invoke(ctx, Schedule_CheckConflict_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) GetScheduleDates(ctx context.Context, in *GetScheduleDatesReq, opts ...grpc.CallOption) (*GetScheduleDatesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetScheduleDatesResp)
	err := c.cc.Invoke(ctx, Schedule_GetScheduleDates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) GetScheduleMonthView(ctx context.Context, in *GetScheduleMonthViewReq, opts ...grpc.CallOption) (*GetScheduleMonthViewResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetScheduleMonthViewResp)
	err := c.cc.Invoke(ctx, Schedule_GetScheduleMonthView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) CreateScheduleMessage(ctx context.Context, in *CreateScheduleMessageReq, opts ...grpc.CallOption) (*CreateScheduleMessageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateScheduleMessageResp)
	err := c.cc.Invoke(ctx, Schedule_CreateScheduleMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) InitScheduleGroups(ctx context.Context, in *InitScheduleGroupsReq, opts ...grpc.CallOption) (*InitScheduleGroupsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitScheduleGroupsResp)
	err := c.cc.Invoke(ctx, Schedule_InitScheduleGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) GetAllScheduleGroups(ctx context.Context, in *GetAllScheduleGroupsReq, opts ...grpc.CallOption) (*GetAllScheduleGroupsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllScheduleGroupsResp)
	err := c.cc.Invoke(ctx, Schedule_GetAllScheduleGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) CreateScheduleGroup(ctx context.Context, in *CreateScheduleGroupReq, opts ...grpc.CallOption) (*CreateScheduleGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateScheduleGroupResp)
	err := c.cc.Invoke(ctx, Schedule_CreateScheduleGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) UpdateScheduleGroup(ctx context.Context, in *UpdateScheduleGroupReq, opts ...grpc.CallOption) (*UpdateScheduleGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScheduleGroupResp)
	err := c.cc.Invoke(ctx, Schedule_UpdateScheduleGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) DeleteScheduleGroup(ctx context.Context, in *DeleteScheduleGroupReq, opts ...grpc.CallOption) (*DeleteScheduleGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteScheduleGroupResp)
	err := c.cc.Invoke(ctx, Schedule_DeleteScheduleGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) QuitScheduleGroup(ctx context.Context, in *QuitScheduleGroupReq, opts ...grpc.CallOption) (*QuitScheduleGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuitScheduleGroupResp)
	err := c.cc.Invoke(ctx, Schedule_QuitScheduleGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleClient) GetScheduleGroupDetail(ctx context.Context, in *GetScheduleGroupDetailReq, opts ...grpc.CallOption) (*GetScheduleGroupDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetScheduleGroupDetailResp)
	err := c.cc.Invoke(ctx, Schedule_GetScheduleGroupDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScheduleServer is the server API for Schedule service.
// All implementations must embed UnimplementedScheduleServer
// for forward compatibility.
//
// Schedule 日程服务
type ScheduleServer interface {
	// 创建日程
	CreateSchedule(context.Context, *CreateScheduleReq) (*CreateScheduleResp, error)
	// 更新日程
	UpdateSchedule(context.Context, *UpdateScheduleReq) (*UpdateScheduleResp, error)
	// 删除日程
	DeleteSchedule(context.Context, *DeleteScheduleReq) (*DeleteScheduleResp, error)
	// 查询日程详情
	GetSchedule(context.Context, *GetScheduleReq) (*GetScheduleResp, error)
	// 查询日程列表
	GetSchedules(context.Context, *GetSchedulesReq) (*GetSchedulesResp, error)
	// 接受日程邀请（支持状态切换：无论当前状态是待确认、已接受还是已拒绝，都可以调用此接口接受日程）
	AcceptSchedule(context.Context, *AcceptScheduleReq) (*AcceptScheduleResp, error)
	// 拒绝日程邀请（支持状态切换：无论当前状态是待确认、已接受还是已拒绝，都可以调用此接口拒绝日程）
	RejectSchedule(context.Context, *RejectScheduleReq) (*RejectScheduleResp, error)
	// 加入日程（主动加入，不是接受邀请。加入后会自动发送日程会话消息给创建者）
	JoinSchedule(context.Context, *JoinScheduleReq) (*JoinScheduleResp, error)
	// 设置提醒
	SetReminder(context.Context, *SetReminderReq) (*SetReminderResp, error)
	// 查询日程冲突
	CheckConflict(context.Context, *CheckConflictReq) (*CheckConflictResp, error)
	// 查询某个月有参与日程的日期列表（用于日历标记）
	GetScheduleDates(context.Context, *GetScheduleDatesReq) (*GetScheduleDatesResp, error)
	// 查询某个月每天的所有日程（月历视图）
	GetScheduleMonthView(context.Context, *GetScheduleMonthViewReq) (*GetScheduleMonthViewResp, error)
	// 发送日程消息到聊天（2个人是单聊，3个及以上是群聊）
	CreateScheduleMessage(context.Context, *CreateScheduleMessageReq) (*CreateScheduleMessageResp, error)
	// 初始化日程分组（创建默认分组）
	InitScheduleGroups(context.Context, *InitScheduleGroupsReq) (*InitScheduleGroupsResp, error)
	// 获取所有日程分组
	GetAllScheduleGroups(context.Context, *GetAllScheduleGroupsReq) (*GetAllScheduleGroupsResp, error)
	// 创建自定义日程分组
	CreateScheduleGroup(context.Context, *CreateScheduleGroupReq) (*CreateScheduleGroupResp, error)
	// 更新日程分组信息
	UpdateScheduleGroup(context.Context, *UpdateScheduleGroupReq) (*UpdateScheduleGroupResp, error)
	// 删除日程分组
	DeleteScheduleGroup(context.Context, *DeleteScheduleGroupReq) (*DeleteScheduleGroupResp, error)
	// 退出日程分组（被共享的用户主动退出他人共享的分组）
	QuitScheduleGroup(context.Context, *QuitScheduleGroupReq) (*QuitScheduleGroupResp, error)
	// 获取日程分组详情
	GetScheduleGroupDetail(context.Context, *GetScheduleGroupDetailReq) (*GetScheduleGroupDetailResp, error)
	mustEmbedUnimplementedScheduleServer()
}

// UnimplementedScheduleServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedScheduleServer struct{}

func (UnimplementedScheduleServer) CreateSchedule(context.Context, *CreateScheduleReq) (*CreateScheduleResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSchedule not implemented")
}
func (UnimplementedScheduleServer) UpdateSchedule(context.Context, *UpdateScheduleReq) (*UpdateScheduleResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSchedule not implemented")
}
func (UnimplementedScheduleServer) DeleteSchedule(context.Context, *DeleteScheduleReq) (*DeleteScheduleResp, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSchedule not implemented")
}
func (UnimplementedScheduleServer) GetSchedule(context.Context, *GetScheduleReq) (*GetScheduleResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSchedule not implemented")
}
func (UnimplementedScheduleServer) GetSchedules(context.Context, *GetSchedulesReq) (*GetSchedulesResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSchedules not implemented")
}
func (UnimplementedScheduleServer) AcceptSchedule(context.Context, *AcceptScheduleReq) (*AcceptScheduleResp, error) {
	return nil, status.Error(codes.Unimplemented, "method AcceptSchedule not implemented")
}
func (UnimplementedScheduleServer) RejectSchedule(context.Context, *RejectScheduleReq) (*RejectScheduleResp, error) {
	return nil, status.Error(codes.Unimplemented, "method RejectSchedule not implemented")
}
func (UnimplementedScheduleServer) JoinSchedule(context.Context, *JoinScheduleReq) (*JoinScheduleResp, error) {
	return nil, status.Error(codes.Unimplemented, "method JoinSchedule not implemented")
}
func (UnimplementedScheduleServer) SetReminder(context.Context, *SetReminderReq) (*SetReminderResp, error) {
	return nil, status.Error(codes.Unimplemented, "method SetReminder not implemented")
}
func (UnimplementedScheduleServer) CheckConflict(context.Context, *CheckConflictReq) (*CheckConflictResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckConflict not implemented")
}
func (UnimplementedScheduleServer) GetScheduleDates(context.Context, *GetScheduleDatesReq) (*GetScheduleDatesResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetScheduleDates not implemented")
}
func (UnimplementedScheduleServer) GetScheduleMonthView(context.Context, *GetScheduleMonthViewReq) (*GetScheduleMonthViewResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetScheduleMonthView not implemented")
}
func (UnimplementedScheduleServer) CreateScheduleMessage(context.Context, *CreateScheduleMessageReq) (*CreateScheduleMessageResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateScheduleMessage not implemented")
}
func (UnimplementedScheduleServer) InitScheduleGroups(context.Context, *InitScheduleGroupsReq) (*InitScheduleGroupsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method InitScheduleGroups not implemented")
}
func (UnimplementedScheduleServer) GetAllScheduleGroups(context.Context, *GetAllScheduleGroupsReq) (*GetAllScheduleGroupsResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllScheduleGroups not implemented")
}
func (UnimplementedScheduleServer) CreateScheduleGroup(context.Context, *CreateScheduleGroupReq) (*CreateScheduleGroupResp, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateScheduleGroup not implemented")
}
func (UnimplementedScheduleServer) UpdateScheduleGroup(context.Context, *UpdateScheduleGroupReq) (*UpdateScheduleGroupResp, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateScheduleGroup not implemented")
}
func (UnimplementedScheduleServer) DeleteScheduleGroup(context.Context, *DeleteScheduleGroupReq) (*DeleteScheduleGroupResp, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteScheduleGroup not implemented")
}
func (UnimplementedScheduleServer) QuitScheduleGroup(context.Context, *QuitScheduleGroupReq) (*QuitScheduleGroupResp, error) {
	return nil, status.Error(codes.Unimplemented, "method QuitScheduleGroup not implemented")
}
func (UnimplementedScheduleServer) GetScheduleGroupDetail(context.Context, *GetScheduleGroupDetailReq) (*GetScheduleGroupDetailResp, error) {
	return nil, status.Error(codes.Unimplemented, "method GetScheduleGroupDetail not implemented")
}
func (UnimplementedScheduleServer) mustEmbedUnimplementedScheduleServer() {}
func (UnimplementedScheduleServer) testEmbeddedByValue()                  {}

// UnsafeScheduleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScheduleServer will
// result in compilation errors.
type UnsafeScheduleServer interface {
	mustEmbedUnimplementedScheduleServer()
}

func RegisterScheduleServer(s grpc.ServiceRegistrar, srv ScheduleServer) {
	// If the following call panics, it indicates UnimplementedScheduleServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Schedule_ServiceDesc, srv)
}

func _Schedule_CreateSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateScheduleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).CreateSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_CreateSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).CreateSchedule(ctx, req.(*CreateScheduleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_UpdateSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).UpdateSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_UpdateSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).UpdateSchedule(ctx, req.(*UpdateScheduleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_DeleteSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScheduleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).DeleteSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_DeleteSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).DeleteSchedule(ctx, req.(*DeleteScheduleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_GetSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScheduleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).GetSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_GetSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).GetSchedule(ctx, req.(*GetScheduleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_GetSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSchedulesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).GetSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_GetSchedules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).GetSchedules(ctx, req.(*GetSchedulesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_AcceptSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptScheduleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).AcceptSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_AcceptSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).AcceptSchedule(ctx, req.(*AcceptScheduleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_RejectSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectScheduleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).RejectSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_RejectSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).RejectSchedule(ctx, req.(*RejectScheduleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_JoinSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinScheduleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).JoinSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_JoinSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).JoinSchedule(ctx, req.(*JoinScheduleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_SetReminder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReminderReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).SetReminder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_SetReminder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).SetReminder(ctx, req.(*SetReminderReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_CheckConflict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckConflictReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).CheckConflict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_CheckConflict_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).CheckConflict(ctx, req.(*CheckConflictReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_GetScheduleDates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScheduleDatesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).GetScheduleDates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_GetScheduleDates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).GetScheduleDates(ctx, req.(*GetScheduleDatesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_GetScheduleMonthView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScheduleMonthViewReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).GetScheduleMonthView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_GetScheduleMonthView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).GetScheduleMonthView(ctx, req.(*GetScheduleMonthViewReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_CreateScheduleMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateScheduleMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).CreateScheduleMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_CreateScheduleMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).CreateScheduleMessage(ctx, req.(*CreateScheduleMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_InitScheduleGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitScheduleGroupsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).InitScheduleGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_InitScheduleGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).InitScheduleGroups(ctx, req.(*InitScheduleGroupsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_GetAllScheduleGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllScheduleGroupsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).GetAllScheduleGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_GetAllScheduleGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).GetAllScheduleGroups(ctx, req.(*GetAllScheduleGroupsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_CreateScheduleGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateScheduleGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).CreateScheduleGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_CreateScheduleGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).CreateScheduleGroup(ctx, req.(*CreateScheduleGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_UpdateScheduleGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduleGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).UpdateScheduleGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_UpdateScheduleGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).UpdateScheduleGroup(ctx, req.(*UpdateScheduleGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_DeleteScheduleGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScheduleGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).DeleteScheduleGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_DeleteScheduleGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).DeleteScheduleGroup(ctx, req.(*DeleteScheduleGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_QuitScheduleGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuitScheduleGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).QuitScheduleGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_QuitScheduleGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).QuitScheduleGroup(ctx, req.(*QuitScheduleGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Schedule_GetScheduleGroupDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScheduleGroupDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServer).GetScheduleGroupDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Schedule_GetScheduleGroupDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServer).GetScheduleGroupDetail(ctx, req.(*GetScheduleGroupDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Schedule_ServiceDesc is the grpc.ServiceDesc for Schedule service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Schedule_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "openim.schedule.Schedule",
	HandlerType: (*ScheduleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSchedule",
			Handler:    _Schedule_CreateSchedule_Handler,
		},
		{
			MethodName: "UpdateSchedule",
			Handler:    _Schedule_UpdateSchedule_Handler,
		},
		{
			MethodName: "DeleteSchedule",
			Handler:    _Schedule_DeleteSchedule_Handler,
		},
		{
			MethodName: "GetSchedule",
			Handler:    _Schedule_GetSchedule_Handler,
		},
		{
			MethodName: "GetSchedules",
			Handler:    _Schedule_GetSchedules_Handler,
		},
		{
			MethodName: "AcceptSchedule",
			Handler:    _Schedule_AcceptSchedule_Handler,
		},
		{
			MethodName: "RejectSchedule",
			Handler:    _Schedule_RejectSchedule_Handler,
		},
		{
			MethodName: "JoinSchedule",
			Handler:    _Schedule_JoinSchedule_Handler,
		},
		{
			MethodName: "SetReminder",
			Handler:    _Schedule_SetReminder_Handler,
		},
		{
			MethodName: "CheckConflict",
			Handler:    _Schedule_CheckConflict_Handler,
		},
		{
			MethodName: "GetScheduleDates",
			Handler:    _Schedule_GetScheduleDates_Handler,
		},
		{
			MethodName: "GetScheduleMonthView",
			Handler:    _Schedule_GetScheduleMonthView_Handler,
		},
		{
			MethodName: "CreateScheduleMessage",
			Handler:    _Schedule_CreateScheduleMessage_Handler,
		},
		{
			MethodName: "InitScheduleGroups",
			Handler:    _Schedule_InitScheduleGroups_Handler,
		},
		{
			MethodName: "GetAllScheduleGroups",
			Handler:    _Schedule_GetAllScheduleGroups_Handler,
		},
		{
			MethodName: "CreateScheduleGroup",
			Handler:    _Schedule_CreateScheduleGroup_Handler,
		},
		{
			MethodName: "UpdateScheduleGroup",
			Handler:    _Schedule_UpdateScheduleGroup_Handler,
		},
		{
			MethodName: "DeleteScheduleGroup",
			Handler:    _Schedule_DeleteScheduleGroup_Handler,
		},
		{
			MethodName: "QuitScheduleGroup",
			Handler:    _Schedule_QuitScheduleGroup_Handler,
		},
		{
			MethodName: "GetScheduleGroupDetail",
			Handler:    _Schedule_GetScheduleGroupDetail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "schedule/schedule.proto",
}
